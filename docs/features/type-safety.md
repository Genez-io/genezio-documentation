---
description: Explore Type Safety with Genezio. Learn how our autogenerated SDK ensures seamless type matching between backend services and clients
---

import Tabs from '@theme/Tabs';

import TabItem from '@theme/TabItem';

# Type Safety

<head>
  <title>Type Safety</title>
</head>

One of the most exciting features of genezio is the guaranteed type safety between backend services and clients, made possible by the autogenerated SDK, which is able to construct types matching the server side types used for the RPC calls exposed to the clients.
This feature is designed to be language agnostic, and with time, genezio will develop support for more and more languages.

Right now, genezio has support for a variety of programming languages on the server side:

- TypeScript
- JavaScript
- Go
- Dart
- Kotlin

and cand export a typesafe SDK in any of the following languages:

- TypeScript
- JavaScript
- Go
- Dart
- Kotlin
- Python
- Swift

## Genezio methods

There are 2 very simple rules for defining type-safe RPC calls in genezio.

- each parameter of a method must be serializable
- the return type of a method must be serializable

## Serializable types

In this section we will take a look at serializable types supported by genezio and their implementation in different languages.

Here is a summary of serializable genezio types:

|                                | TS  | Go  | Dart | Kotlin |
| ------------------------------ | --- | --- | ---- | ------ |
| [Primitives](#primitive-types) | ✅  | ✅  | ✅   | ✅     |
| [Objects](#objects)            | ✅  | ✅  | ✅   | ✅     |
| [Arrays](#arrays)              | ✅  | ✅  | ✅   | ✅     |
| [Maps](#paps)                  | ✅  | ✅  | ❌   | ✅     |
| [Enums](#enums)                | ✅  | ❌  | ❌   | ✅     |
| [Unions](#unions)              | ✅  | ❌  | ❌   | ❌     |
| [Any](#any-values)             | ✅  | ✅  | ✅   | ✅     |
| Interfaces                     | ❌  | ❌  | ❌   | ❌     |

### Primitive types

<Tabs>
    <TabItem className="tab-item" value="ts" label="TypeScript">
        - number
        - string
        - boolean
    </TabItem>
    <TabItem className="tab-item" value="go" label="Go">
        - int
        - float64
        - string
        - bool
    </TabItem>
</Tabs>

### Objects

An object is serializable if all of its fields are serializable.

<Tabs>
    <TabItem className="tab-item" value="ts" label="TypeScript">
There are many ways of declaring objects in TypeScript. Genezio prefers type aliases instead of interfaces or classes.

```typescript
type Person = {
  name: string;
  age: number;
};
```

    </TabItem>
    <TabItem className="tab-item" value="go" label="Go">

```go
type Person struct {
    Name string
    Age  number
}
```

    </TabItem>

</Tabs>

### Arrays

An array of a type T is serializable if T is serializable

<Tabs>
    <TabItem className="tab-item" value="ts" label="TypeScript">

```typescript
type User = {
  name: string;
  age: number;
};

@GenezioDeploy()
export class UserService {
  getNames(users: User[]): string[] {
    return users.map((p) => p.name);
  }
}
```

    </TabItem>
    <TabItem className="tab-item" value="go" label="Go">

```go
type User struct {
    Name string
    Age number
}

type UserService struct {}

func New() UserService {
    return UserService{}
}

func (s *UserService) GetNames(users []User) ([]string, error) {
	var names []string
	for _, user := range users {
		names = append(names, user.Name)
	}
	return names, nil
}
```

    </TabItem>

</Tabs>

### Maps

A map with keys of type `string` and values of type T is serializable is T is serializable

<Tabs>
    <TabItem className="tab-item" value="ts" label="TypeScript">

```typescript
type User = {
  name: string;
  age: number;
};

@GenezioDeploy()
export class UserService {
  getUserForKey(users: { [key: string]: User }, key: string): User {
    return users[key];
  }
}
```

    </TabItem>
    <TabItem className="tab-item" value="go" label="Go">

```go
type User struct {
    Name string
    Age int
}

type UserService struct {}

func New() UserService {
    return UserService{}
}

func (s *UserService) GetUserForKey(users map[string]User, key string) (User, error) {
    return users[key]
}
```

    </TabItem>

</Tabs>

### Enums

Enums representing consecutive numbers starting from 0 are serializable

<Tabs>
    <TabItem className="tab-item" value="ts" label="TypeScript">

```typescript
export enum Season {
  WINTER,
  SPRING,
  SUMMER,
  AUTUMN,
}

@GenezioDeploy()
export class UserService {
  getSeasonTemperature(season: Season): number {
    switch (season) {
      case Season.WINTER:
        return 0;
      case Season.SPRING:
        return 15;
      case Season.SUMMER:
        return 30;
      case Season.AUTUMN:
        return 10;
    }
  }
}
```

    </TabItem>
    <TabItem className="tab-item" value="go" label="Go">
    Currently not supported. Comming soon!
    </TabItem>

</Tabs>

### Unions

<Tabs>
    <TabItem className="tab-item" value="ts" label="TypeScript">
    A union in typescript is serializable if all of its types are serializable

```typescript
type City = {
  name: string;
  population: number;
};

type Country = {
  name: string;
  language: string;
};

@GenezioDeploy()
export class UserService {
  getName(a: City | Country): string {
    return a.name;
  }
}
```

    </TabItem>
    <TabItem className="tab-item" value="go" label="Go">
    Not supported.
    </TabItem>

</Tabs>

### "Any" values

There are a few instances when genezio cannot construct a client type for the SDK, or the server type is explicitly defined as an "any" type. Genezio will use the most generic type available in the target language.

<Tabs>
    <TabItem className="tab-item" value="ts" label="TypeScript">
        `any`
    </TabItem>
    <TabItem className="tab-item" value="go" label="Go">
        `interface{}`
    </TabItem>
</Tabs>
